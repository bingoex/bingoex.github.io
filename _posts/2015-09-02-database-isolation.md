---
layout: post
title: 事务的隔离性
categories: 数据库
description: 事务的隔离性
keywords: 事务的隔离性, 隔离性
---


| 事务级别 |脏读 |不可重复读 |幻读 |
|Read uncommitted |√ |√ |√ |
|Read committed |× |√ |√ |
|Repeatable read |× |× |√ |
|Serializable |× |× |× |
√: 可能出现    ×: 不会出现


# Read uncommitted 读未提交

公司发工资了，领导把5000元打到富强的账号上，但是该事务并未提交，而富强正好去查看账户，发现工资已经到账，是5000元整，非常高兴。可是不幸的是，领导发现发给富强的工资金额不对，是2000元，于是迅速回滚了事务，修改金额后，将事务提交，最后富强实际的工资只有2000元，富强空欢喜一场。

出现上述情况，即我们所说的**脏读**，两个并发的事务，“事务A：领导给富强发工资”、“事务B：富强查询工资账户”，**事务B读取了事务A尚未提交的数据**。

当隔离级别设置为**Read uncommitted时，就可能出现脏读**，如何避免脏读，请看下一个隔离级别。


# Read committed 读提交

富强拿着工资卡去消费，系统读取到卡里确实有2000元，而此时她的老婆也正好在网上转账，把富强工资卡的2000元转到另一账户，并在富强之前提交了事务，当富强扣款时，系统检查到富强的工资卡已经没有钱，扣款失败，富强十分纳闷，明明卡里有钱，为何......

出现上述情况，即我们所说的**不可重复读**，两个并发的事务，“事务A：富强消费”、“事务B：富强的老婆网上转账”，**事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变**。(重点是修改)**

当隔离级别设置为Read committed时，**避免了脏读**，但是可能会**造成不可重复读**。

大多数数据库的默认级别就是Read committed，比如Sql Server , Oracle。


# Repeatable read 重复读

当隔离级别设置为**Repeatable read时，可以避免不可重复读**。**当富强拿着工资卡去消费时，一旦系统开始读取工资卡信息（即事务开始），富强的老婆就不可能对该记录进行修改，也就是富强的老婆不能在此时转账（注意：这里只是不给修改，但是仍然可以新增数据！）**。

虽然Repeatable read**避免了不可重复读**，但还有**可能出现幻读**。

富强的老婆工作在银行部门，她时常通过银行内部系统查看富强的信用卡消费记录。有一天，她正在查询到富强当月信用卡的总消费金额（select sum(amount) from transactionwhere month = 本月）为80元，而富强此时正好在外面胡吃海塞后在收银台买单，消费1000元，即新增了一条1000元的消费记录（insert transaction ... ），并提交了事务，随后富强的老婆将富强当月信用卡消费的明细打印到A4纸上，却发现消费总额为1080元，富强的老婆很诧异，以为出现了幻觉，幻读就这样产生了。

注：**Mysql的默认隔离级别就是Repeatable read**。


# Serializable 序列化

Serializable是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，**事务顺序执行**，不仅可以避免脏读、不可重复读，还避免了幻像读。**因使用了[gap锁](http://www.cnblogs.com/hellopretty/p/5020093.html)，导致了别的事务B不能对事物A相关的数据进行增加和修改的操作**。
 

